---
sidebar: auto
title: '单点登录'
---

## 起因

假如你正在a.com下购买商品，然后又去到b.com下购买商品，如果a.com和b.com是同属于一个公司的，那么用户当然是希望在a.com或者b.com登录了之后就可以随意浏览，而不是既需要登录a.com又登录b.com。实现自动登录的手段可以通过cookie，但是跨域是无法携带cookie的，因此就需要一个机制去实现跨域的单点登录。



## 不同域下的单点登录（CAS）

这里借用网上一张图

![](https://yqfile.alicdn.com/dcb743204f8a201be53df5338fc34affe5fa1059.png)

一开始的时候看了很多关于单点登录的博客，希望能快速了解单点登录的原理，但是基本都会看到类似上面的这种图，因此不得不沉下心来消化这张流程图，耐心看完之后就觉得其实还是挺简单的，然后自己希望使用koa进行简单的实现，以此更深入了解SSO原理。

## 代码实现（基于Koa）

从图中可以看到主要有浏览器、CAS Server和另外两个App（即提供服务的服务器）。在敲下面代码之前，在hosts文件添加以下信息：

```js
127.0.0.1 a.com
127.0.0.1 b.com
127.0.0.1 c.com
```

```js
// App1
const Koa = require('koa')
const Router = require('koa-router')
const axios = require('axios')

const app = new Koa()
const router = new Router()

const one = require('./1.js')

app.use(async (ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', 'http://c.com:3335')
  ctx.set('Access-Control-Allow-Headers', 'x-requested-with')
  await next()
})

router.get('/', async (ctx) => {
  if (ctx.query.ticket) {
    await axios.get('http://c.com:3335/auth/?ticket=' + ctx.query.ticket)
      .then(res => {
        if (res.data === 'success') {
          ctx.cookies.set('name', 'lim')
          ctx.redirect('http://a.com:3333')
        }
      })
  } else if (ctx.cookies.get('name') === 'lim') {
    ctx.body = one
  } else {
    ctx.redirect('http://c.com:3335/?service=http://a.com:3333')
  }
})

app.use(router.routes()).use(router.allowedMethods())

app.listen(3333, '127.0.0.1', () => {
  console.log(`server is listening on 0.0.0.0:3333`)
})
```

a.com:3333充当着App1的角色，当我们访问a.com:3333时，该服务会处理get请求，处理get请求的函数有3中情况，我们先按照上图CAS流程看最后一种情况（没有登录并且url不带参数），这个时候服务器会重定向至CAS Server，重定向的Location字段是`http://c.com:3335/?service=http://a.com:3333`，带上service字段是为了告知CAS Server成功登录之后重定向的目的地，举个例子：用户访问a.com，然后被重定向到一个登录页面，用户登录完成后，CAS Server就应该将页面重定向回a.com，而不是b.com。

然后看看重定向到CAS Server之后，该服务器做了什么事情。

```js
// CAS Server
const Koa = require('koa')
const Router = require('koa-router')
const koaBody = require('koa-body')

const app = new Koa()
const router = new Router()

const one = require('./1.js')

router.get('/', async (ctx) => {
  if (ctx.cookies.get('name') === 'lim') {
    ctx.redirect(ctx.query.service + '/?ticket=123')
  } else {
    ctx.body = one
  }
})

router.post('/', async (ctx) => {
  ctx.cookies.set('name', 'lim')
  ctx.body = 'ticket=123'
})

router.get('/auth', async (ctx) => {
  if (ctx.query.ticket === '123') {
    ctx.body = 'success'
  }
})

app.use(koaBody())
app.use(router.routes()).use(router.allowedMethods())

app.listen('3335', '127.0.0.1', () => {
  console.log('listen on 127.0.0.1:3335')
})
```

c.com:3335充当CAS Server的角色。该服务器处理路由`/`的get请求时有两种情况，我们先看第二种，即用户没有登录的情况，这个时候页面返回一个登录页面（变量one的内容是1.js中的内容，看下面代码）。可以看到1.js定义的html页面只有一个button元素，还有一个script标签，定义了点击button之后的回调函数。点击login这个button之后，会向c.com:3335发出post请求，回去看c.com:3335处理post请求的函数，就是设置c.com域下的cookie，并且返回一个ticket，该ticket是为了传回a.com进行验证用的，可以从流程图中看出来。再回到点击button之后的回调函数，它将页面请求回a.com，并且带上CAS Server传过来的ticket。

```js
// CAS Server's 1.js
module.exports = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <button>login</button>
  <script src="http://code.jquery.com/jquery-2.1.1.min.js"></script>
  <script>
    $('button').click(function () {
      $.post('http://c.com:3335', function (res) {
        const targetURL = location.search.split('=')[1]
        location.href = targetURL + '/?' + res
      })
    })
  </script>
</body>
</html>
`
```

这个时候，看回下面App1处理get的代码：这个时候代码就会执行第一种情况，即url携带ticket参数，然后该服务器就会向CAS Server发出一个请求，用于验证ticket的合法性，可以回去CAS Server代码中查看处理路由`/auth`的函数，其实就是看ticket是否是CAS Server传过去的。当验证成功后，就会执行then中的回调函数，该回调函数就会设置a.com域下的cookie，然后将页面重定向至a.com:3333。

```js
router.get('/', async (ctx) => {
  if (ctx.query.ticket) {
    await axios.get('http://c.com:3335/auth/?ticket=' + ctx.query.ticket)
      .then(res => {
        if (res.data === 'success') {
          ctx.cookies.set('name', 'lim')
          ctx.redirect('http://a.com:3333')
        }
      })
  } else if (ctx.cookies.get('name') === 'lim') {
    ctx.body = one
  } else {
    ctx.redirect('http://c.com:3335/?service=http://a.com:3333')
  }
})
```

这个时候重新访问a.com，就会执行get请求的第二个情况，检验是否有cookie，有的话就返回一个html页面。至此，再次访问a.com就可以自动登录了，因为该域下保存了cookie。

再来看看访问b.com:3334会发生什么，来看看App2的代码：

```js
const Koa = require('koa')
const Router = require('koa-router')
const axios = require('axios')

const app = new Koa()
const router = new Router()

const one = require('./1.js')

router.get('/', async (ctx) => {
  if (ctx.query.ticket) {
    await axios
      .get('http://c.com:3335/auth/?ticket=' + ctx.query.ticket)
      .then(res => {
        if (res.data === 'success') {
          ctx.cookies.set('name', 'lim')
          ctx.redirect('http://b.com:3334')
        }
      })
  } else if (ctx.cookies.get('name') === 'lim') {
    ctx.body = one
  } else {
    ctx.redirect('http://c.com:3335/?service=http://b.com:3334')
  }
})

app.use(router.routes()).use(router.allowedMethods())

app.listen('3334', '127.0.0.1', () => {
  console.log(`server is listening on 0.0.0.0:3334`)
})
```

这个代码和App1是一样的，不同的就是重定向至CAS Server的登录页面时携带的url参数不同。当我们访问了a.com:3333并登录了之后，再访问b.com:3334，b.com:3334的代码就会重定向至CAS Server，再次看看CAS Server处理get请求的函数:

```js
router.get('/', async (ctx) => {
  if (ctx.cookies.get('name') === 'lim') {
    ctx.redirect(ctx.query.service + '/?ticket=123')
  } else {
    ctx.body = one
  }
})
```

这个时候会代码会执行第一种情况，而不是返回一个登录页面，因为第一次访问a.com:3333时进行了登录，CAS Server在处理登录的post请求时就设置了c.com域下的cookie，因此当访问b.com:3334时，CAS Server就会直接重定向回b.com:3334，并携带一个ticket，后续过程和App1就是一样的了，就是检验ticket合法性，然后设置b.com域下的cookie，然后就实现了自动登录。



## 参考

[单点登录](<https://yq.aliyun.com/articles/636281>)

