---
title: '微前端'
---

# 微前端

## Single-SPA

### Concept Microfrontend

- 每个微前端应该有自己的git仓库，有独立的构建流程，例如CI/CD。
- 和微服务相比：
  - 每个微服务可能涉及数据库存取，其他服务调用等，相互之间是网络请求；而微前端之间的通信则是基于内存的。
  - 相同的是都具有独立构建和发布流程。
- 微前端的类型：
  - application
  - pacel
  - utility
- single-spa的角色
  - 负责编排微前端
- 性能
  - 内置懒加载方法和其他懒加载方法

### Concept Root Config

- root config包含
  - 应用共享的root html文件
  - 调用了`singleSpa.registerApplication()`的js文件
- 并不一定要使用`SystemJS`，但是它可以帮助你独立发布应用
- `registerApplication`参数
  - 第一个参数是application name
  - 第二个参数是loading function或者包含应用生命周期的对象
    - loading function需要返回一个`Promise`，该`Promise`实例需要`resolve`一个应用，例如：`() => import('path/to/application.js')`
    - 包含生命周期的对象具有`bootstrap`、`mount`、`unmount`方法
  - 第三个参数是activity function
    - 该函数接受`window.location`作为参数，并返回一个布尔值
  - 第四个参数是custom props
    - custom props会作为参数传递给子应用的生命周期函数
  - 也可以传入一个对象
    - name: string
    - app: function
    - activeWhen: string
    - customProps: object
- `start`
  - `start`方法可以帮助更好控制何时显示应用，例如等待必须的Ajax请求完成后仔触发应用的挂载。

### Concept Application

- 生命周期props
  - 内置props
    - name：应用名称
    - singleSpa：singleSpa实例，允许子应用或工具库直接调用singleSpa的api而无需import。
    - moutParcel
  - 自定义props
    - 一些用例：
      - 子应用共享access token
      - 传递初始化信息，例如挂载目标
      - 传递事件总线的引用，使得应用相互直接得以通信
  - Load
  - Bootstrap
    - 只会在应用第一次挂载时调用
  - Mount
    - 应用挂载时调用。应用子路由发生变化时不会调用，其变化交由应用本身处理
  - Unmount
    - 应用卸载时调用，该方法中可以清除副作用，例如DOM事件监听等
  - Unload
    - 该函数只有调用`unloadApplication`时才会调用。
    - 该生命周期的目的是hot-reloading
- 可以设置各个声明周期函数的超时时长
- 在应用之间transition可以参考[singlespa-transitions](https://github.com/frehner/singlespa-transitions)，应用内部transition可以参考[react-transition-group](https://github.com/reactjs/react-transition-group)
- 拆分应用
  - 使用`SystemJS`动态加载模块

### Concept Parcel

parcel是框架无关的组件。与应用相似，但是需要手动调用函数进行挂载。

如果应用使用了框架，那么更倾向于使用与框架相关的组件，组件之间更易于通信。

### The Recommended Setup

建议使用ES modules + import maps（或者`SystemJS`），具有以下好处：

- 公共库易于管理并且只需要下载一次，如果使用`SystemJS`，可以预加载以提升启动速度
- 共享代码、函数、变量更加易于导入导出，和单体应用一样
- 易于懒加载应用，加快应用初始启动
- 每个应用可以独立开发和发布。团队可以并行开发
- 良好的开发体验：在各自的开发环境增加import map，执行本地url

#### Alternatives

- [qiankun](https://github.com/umijs/qiankun)
- [ilc](https://github.com/namecheap/ilc)：支持SPA和SSR

#### In-browser versus build-time modules

in-browser模块指应用中不由打包工具编译的模块；build-time模块指由应用中`node_modules`提供并编译的模块。

通过`webpack externals`和`rollup externals`将应用中部分依赖外置。

- 每个spa应用应该是一个in-browser模块
- 大型共享依赖，如react、vue应该是一个in-browser模块
- 其他的应该是build-time模块

#### Import Maps

[Import Maps](https://github.com/WICG/import-maps)用于查找`import specifier`对应的URL。

```js
// ./thing.js is the import specifier
import thing from './thing.js';
// react is the import specifier
import React from 'react';
```

上述react是一个`bare specifier`，其不是一个相对路径或者完整URL，import maps可以解决这个问题，找到其对应的URL。

#### Module Federation

[Module Federation](https://dev.to/marais/webpack-5-and-module-federation-4j1i)是webpack用于共享build-time module的方法。

[YouTube video](https://www.youtube.com/watch?v=wxnwPLLIJCY)讲述了在single-spa中使用module federation。

建议第三方依赖采用import map，其他模块采用module federation。

#### SystemJS







## 阅读链接

- [微前端在美团外卖的实践](https://zhuanlan.zhihu.com/p/109548596)

- [微前端说明书](https://zhuanlan.zhihu.com/p/82051427)
- [微前端究竟好在哪？](https://www.infoq.cn/article/eak269wctZckcG3Spm2o)

- [single-spa](https://single-spa.js.org/docs/getting-started-overview)

- [目标是最完善的微前端解决方案 - qiankun 2.0](https://zhuanlan.zhihu.com/p/131022025)

